/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript&plugins=line-numbers+normalize-whitespace */
var _self = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : {}; var Prism = (function () { var e = /\blang(?:uage)?-([\w-]+)\b/i; var t = 0; var n = _self.Prism = { manual: _self.Prism && _self.Prism.manual, disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler, util: { encode: function (e) { return e instanceof r ? new r(e.type, n.util.encode(e.content), e.alias) : n.util.type(e) === 'Array' ? e.map(n.util.encode) : e.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ') }, type: function (e) { return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1] }, objId: function (e) { return e.__id || Object.defineProperty(e, '__id', { value: ++t }), e.__id }, clone: function (e, t) { var r = n.util.type(e); switch (t = t || {}, r) { case 'Object':if (t[n.util.objId(e)]) return t[n.util.objId(e)]; var a = {}; t[n.util.objId(e)] = a; for (var l in e)e.hasOwnProperty(l) && (a[l] = n.util.clone(e[l], t)); return a; case 'Array':if (t[n.util.objId(e)]) return t[n.util.objId(e)]; var a = []; return t[n.util.objId(e)] = a, e.forEach(function (e, r) { a[r] = n.util.clone(e, t) }), a } return e } }, languages: { extend: function (e, t) { var r = n.util.clone(n.languages[e]); for (var a in t)r[a] = t[a]; return r }, insertBefore: function (e, t, r, a) { a = a || n.languages; var l = a[e]; if (arguments.length == 2) { r = arguments[1]; for (var i in r)r.hasOwnProperty(i) && (l[i] = r[i]); return l } var o = {}; for (var s in l) if (l.hasOwnProperty(s)) { if (s == t) for (var i in r)r.hasOwnProperty(i) && (o[i] = r[i]); o[s] = l[s] } var u = a[e]; return a[e] = o, n.languages.DFS(n.languages, function (t, n) { n === u && t != e && (this[t] = o) }), o }, DFS: function (e, t, r, a) { a = a || {}; for (var l in e)e.hasOwnProperty(l) && (t.call(e, l, e[l], r || l), n.util.type(e[l]) !== 'Object' || a[n.util.objId(e[l])] ? n.util.type(e[l]) !== 'Array' || a[n.util.objId(e[l])] || (a[n.util.objId(e[l])] = !0, n.languages.DFS(e[l], t, l, a)) : (a[n.util.objId(e[l])] = !0, n.languages.DFS(e[l], t, null, a))) } }, plugins: {}, highlightAll: function (e, t) { n.highlightAllUnder(document, e, t) }, highlightAllUnder: function (e, t, r) { var a = { callback: r, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; n.hooks.run('before-highlightall', a); for (var l, i = a.elements || e.querySelectorAll(a.selector), o = 0; l = i[o++];)n.highlightElement(l, t === !0, a.callback) }, highlightElement: function (t, r, a) { for (var l, i, o = t; o && !e.test(o.className);)o = o.parentNode; o && (l = (o.className.match(e) || [, ''])[1].toLowerCase(), i = n.languages[l]), t.className = t.className.replace(e, '').replace(/\s+/g, ' ') + ' language-' + l, t.parentNode && (o = t.parentNode, /pre/i.test(o.nodeName) && (o.className = o.className.replace(e, '').replace(/\s+/g, ' ') + ' language-' + l)); var s = t.textContent; var u = { element: t, language: l, grammar: i, code: s }; if (n.hooks.run('before-sanity-check', u), !u.code || !u.grammar) return u.code && (n.hooks.run('before-highlight', u), u.element.textContent = u.code, n.hooks.run('after-highlight', u)), n.hooks.run('complete', u), void 0; if (n.hooks.run('before-highlight', u), r && _self.Worker) { var g = new Worker(n.filename); g.onmessage = function (e) { u.highlightedCode = e.data, n.hooks.run('before-insert', u), u.element.innerHTML = u.highlightedCode, a && a.call(u.element), n.hooks.run('after-highlight', u), n.hooks.run('complete', u) }, g.postMessage(JSON.stringify({ language: u.language, code: u.code, immediateClose: !0 })) } else u.highlightedCode = n.highlight(u.code, u.grammar, u.language), n.hooks.run('before-insert', u), u.element.innerHTML = u.highlightedCode, a && a.call(t), n.hooks.run('after-highlight', u), n.hooks.run('complete', u) }, highlight: function (e, t, a) { var l = { code: e, grammar: t, language: a }; return n.hooks.run('before-tokenize', l), l.tokens = n.tokenize(l.code, l.grammar), n.hooks.run('after-tokenize', l), r.stringify(n.util.encode(l.tokens), l.language) }, matchGrammar: function (e, t, r, a, l, i, o) { var s = n.Token; for (var u in r) if (r.hasOwnProperty(u) && r[u]) { if (u == o) return; var g = r[u]; g = n.util.type(g) === 'Array' ? g : [g]; for (var c = 0; c < g.length; ++c) { var h = g[c]; var f = h.inside; var d = !!h.lookbehind; var m = !!h.greedy; var p = 0; var y = h.alias; if (m && !h.pattern.global) { var v = h.pattern.toString().match(/[imuy]*$/)[0]; h.pattern = RegExp(h.pattern.source, v + 'g') }h = h.pattern || h; for (var b = a, k = l; b < t.length; k += t[b].length, ++b) { var w = t[b]; if (t.length > e.length) return; if (!(w instanceof s)) { if (m && b != t.length - 1) { h.lastIndex = k; var _ = h.exec(e); if (!_) break; for (var j = _.index + (d ? _[1].length : 0), P = _.index + _[0].length, A = b, x = k, O = t.length; O > A && (P > x || !t[A].type && !t[A - 1].greedy); ++A)x += t[A].length, j >= x && (++b, k = x); if (t[b] instanceof s) continue; I = A - b, w = e.slice(k, x), _.index -= k } else { h.lastIndex = 0; var _ = h.exec(w); var I = 1 } if (_) { d && (p = _[1] ? _[1].length : 0); var j = _.index + p; var _ = _[0].slice(p); var P = j + _.length; var N = w.slice(0, j); var S = w.slice(P); var C = [b, I]; N && (++b, k += N.length, C.push(N)); var E = new s(u, f ? n.tokenize(_, f) : _, y, _, m); if (C.push(E), S && C.push(S), Array.prototype.splice.apply(t, C), I != 1 && n.matchGrammar(e, t, r, b, k, !0, u), i) break } else if (i) break } } } } }, tokenize: function (e, t) { var r = [e]; var a = t.rest; if (a) { for (var l in a)t[l] = a[l]; delete t.rest } return n.matchGrammar(e, r, t, 0, 0, !1), r }, hooks: { all: {}, add: function (e, t) { var r = n.hooks.all; r[e] = r[e] || [], r[e].push(t) }, run: function (e, t) { var r = n.hooks.all[e]; if (r && r.length) for (var a, l = 0; a = r[l++];)a(t) } } }; var r = n.Token = function (e, t, n, r, a) { this.type = e, this.content = t, this.alias = n, this.length = 0 | (r || '').length, this.greedy = !!a }; if (r.stringify = function (e, t, a) { if (typeof e === 'string') return e; if (n.util.type(e) === 'Array') return e.map(function (n) { return r.stringify(n, t, e) }).join(''); var l = { type: e.type, content: r.stringify(e.content, t, a), tag: 'span', classes: ['token', e.type], attributes: {}, language: t, parent: a }; if (e.alias) { var i = n.util.type(e.alias) === 'Array' ? e.alias : [e.alias]; Array.prototype.push.apply(l.classes, i) }n.hooks.run('wrap', l); var o = Object.keys(l.attributes).map(function (e) { return e + '="' + (l.attributes[e] || '').replace(/"/g, '&quot;') + '"' }).join(' '); return '<' + l.tag + ' class="' + l.classes.join(' ') + '"' + (o ? ' ' + o : '') + '>' + l.content + '</' + l.tag + '>' }, !_self.document) return _self.addEventListener ? (n.disableWorkerMessageHandler || _self.addEventListener('message', function (e) { var t = JSON.parse(e.data); var r = t.language; var a = t.code; var l = t.immediateClose; _self.postMessage(n.highlight(a, n.languages[r], r)), l && _self.close() }, !1), _self.Prism) : _self.Prism; var a = document.currentScript || [].slice.call(document.getElementsByTagName('script')).pop(); return a && (n.filename = a.src, n.manual || a.hasAttribute('data-manual') || (document.readyState !== 'loading' ? window.requestAnimationFrame ? window.requestAnimationFrame(n.highlightAll) : window.setTimeout(n.highlightAll, 16) : document.addEventListener('DOMContentLoaded', n.highlightAll))), _self.Prism }()); typeof module !== 'undefined' && module.exports && (module.exports = Prism), typeof global !== 'undefined' && (global.Prism = Prism)
Prism.languages.markup = { comment: /<!--[\s\S]*?-->/, prolog: /<\?[\s\S]+?\?>/, doctype: /<!DOCTYPE[\s\S]+?>/i, cdata: /<!\[CDATA\[[\s\S]*?]]>/i, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/i, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, 'attr-value': { pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i, inside: { punctuation: [/^=/, { pattern: /(^|[^\\])["']/, lookbehind: !0 }] } }, punctuation: /\/?>/, 'attr-name': { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: /&#?[\da-z]{1,8};/i }, Prism.languages.markup.tag.inside['attr-value'].inside.entity = Prism.languages.markup.entity, Prism.hooks.add('wrap', function (a) { a.type === 'entity' && (a.attributes.title = a.content.replace(/&amp;/, '&')) }), Prism.languages.xml = Prism.languages.markup, Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup
Prism.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i, inside: { rule: /@[\w-]+/ } }, url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i, selector: /[^{}\s][^{};]*?(?=\s*\{)/, string: { pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i, important: /!important\b/i, 'function': /[-a-z0-9]+(?=\()/i, punctuation: /[(){};:]/ }, Prism.languages.css.atrule.inside.rest = Prism.languages.css, Prism.languages.markup && (Prism.languages.insertBefore('markup', 'tag', { style: { pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i, lookbehind: !0, inside: Prism.languages.css, alias: 'language-css', greedy: !0 } }), Prism.languages.insertBefore('inside', 'attr-value', { 'style-attr': { pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i, inside: { 'attr-name': { pattern: /^\s*style/i, inside: Prism.languages.markup.tag.inside }, punctuation: /^\s*=\s*['"]|['"]\s*$/, 'attr-value': { pattern: /.+/i, inside: Prism.languages.css } }, alias: 'language-css' } }, Prism.languages.markup.tag))

Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, 'class-name': { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, 'boolean': /\b(?:true|false)\b/, 'function': /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ }
Prism.languages.javascript = Prism.languages.extend('clike', { 'class-name': [Prism.languages.clike['class-name'], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: !0 }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: !0 }, /\b(?:as|async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/], number: /\b(?:(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+)n?|\d+n|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/, 'function': /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\(|\.(?:apply|bind|call)\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ }), Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, Prism.languages.insertBefore('javascript', 'keyword', { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^\/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: !0, greedy: !0 }, 'function-variable': { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i, alias: 'function' }, constant: /\b[A-Z][A-Z\d_]*\b/ }), Prism.languages.insertBefore('javascript', 'string', { 'template-string': { pattern: /`(?:\\[\s\S]|\${[^}]+}|[^\\`])*`/, greedy: !0, inside: { interpolation: { pattern: /\${[^}]+}/, inside: { 'interpolation-punctuation': { pattern: /^\${|}$/, alias: 'punctuation' }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } } }), Prism.languages.markup && Prism.languages.insertBefore('markup', 'tag', { script: { pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i, lookbehind: !0, inside: Prism.languages.javascript, alias: 'language-javascript', greedy: !0 } }), Prism.languages.js = Prism.languages.javascript
!(function () { if (typeof self !== 'undefined' && self.Prism && self.document) { var e = 'line-numbers'; var t = /\n(?!$)/g; var n = function (e) { var n = r(e); var s = n['white-space']; if (s === 'pre-wrap' || s === 'pre-line') { var l = e.querySelector('code'); var i = e.querySelector('.line-numbers-rows'); var a = e.querySelector('.line-numbers-sizer'); var o = l.textContent.split(t); a || (a = document.createElement('span'), a.className = 'line-numbers-sizer', l.appendChild(a)), a.style.display = 'block', o.forEach(function (e, t) { a.textContent = e || '\n'; var n = a.getBoundingClientRect().height; i.children[t].style.height = n + 'px' }), a.textContent = '', a.style.display = 'none' } }; var r = function (e) { return e ? window.getComputedStyle ? getComputedStyle(e) : e.currentStyle || null : null }; window.addEventListener('resize', function () { Array.prototype.forEach.call(document.querySelectorAll('pre.' + e), n) }), Prism.hooks.add('complete', function (e) { if (e.code) { var r = e.element.parentNode; var s = /\s*\bline-numbers\b\s*/; if (r && /pre/i.test(r.nodeName) && (s.test(r.className) || s.test(e.element.className)) && !e.element.querySelector('.line-numbers-rows')) { s.test(e.element.className) && (e.element.className = e.element.className.replace(s, ' ')), s.test(r.className) || (r.className += ' line-numbers'); var l; var i = e.code.match(t); var a = i ? i.length + 1 : 1; var o = new Array(a + 1); o = o.join('<span></span>'), l = document.createElement('span'), l.setAttribute('aria-hidden', 'true'), l.className = 'line-numbers-rows', l.innerHTML = o, r.hasAttribute('data-start') && (r.style.counterReset = 'linenumber ' + (parseInt(r.getAttribute('data-start'), 10) - 1)), e.element.appendChild(l), n(r), Prism.hooks.run('line-numbers', e) } } }), Prism.hooks.add('line-numbers', function (e) { e.plugins = e.plugins || {}, e.plugins.lineNumbers = !0 }), Prism.plugins.lineNumbers = { getLine: function (t, n) { if (t.tagName === 'PRE' && t.classList.contains(e)) { var r = t.querySelector('.line-numbers-rows'); var s = parseInt(t.getAttribute('data-start'), 10) || 1; var l = s + (r.children.length - 1); s > n && (n = s), n > l && (n = l); var i = n - s; return r.children[i] } } } } }())
!(function () { function e (e) { this.defaults = r({}, e) } function n (e) { return e.replace(/-(\w)/g, function (e, n) { return n.toUpperCase() }) } function t (e) { for (var n = 0, t = 0; t < e.length; ++t)e.charCodeAt(t) == '	'.charCodeAt(0) && (n += 3); return e.length + n } var r = Object.assign || function (e, n) { for (var t in n)n.hasOwnProperty(t) && (e[t] = n[t]); return e }; e.prototype = { setDefaults: function (e) { this.defaults = r(this.defaults, e) }, normalize: function (e, t) { t = r(this.defaults, t); for (var i in t) { var o = n(i); i !== 'normalize' && o !== 'setDefaults' && t[i] && this[o] && (e = this[o].call(this, e, t[i])) } return e }, leftTrim: function (e) { return e.replace(/^\s+/, '') }, rightTrim: function (e) { return e.replace(/\s+$/, '') }, tabsToSpaces: function (e, n) { return n = 0 | n || 4, e.replace(/\t/g, new Array(++n).join(' ')) }, spacesToTabs: function (e, n) { return n = 0 | n || 4, e.replace(RegExp(' {' + n + '}', 'g'), '	') }, removeTrailing: function (e) { return e.replace(/\s*?$/gm, '') }, removeInitialLineFeed: function (e) { return e.replace(/^(?:\r?\n|\r)/, '') }, removeIndent: function (e) { var n = e.match(/^[^\S\n\r]*(?=\S)/gm); return n && n[0].length ? (n.sort(function (e, n) { return e.length - n.length }), n[0].length ? e.replace(RegExp('^' + n[0], 'gm'), '') : e) : e }, indent: function (e, n) { return e.replace(/^[^\S\n\r]*(?=\S)/gm, new Array(++n).join('	') + '$&') }, breakLines: function (e, n) { n = n === !0 ? 80 : 0 | n || 80; for (var r = e.split('\n'), i = 0; i < r.length; ++i) if (!(t(r[i]) <= n)) { for (var o = r[i].split(/(\s+)/g), a = 0, s = 0; s < o.length; ++s) { var l = t(o[s]); a += l, a > n && (o[s] = '\n' + o[s], a = l) }r[i] = o.join('') } return r.join('\n') } }, typeof module !== 'undefined' && module.exports && (module.exports = e), typeof Prism !== 'undefined' && (Prism.plugins.NormalizeWhitespace = new e({ 'remove-trailing': !0, 'remove-indent': !0, 'left-trim': !0, 'right-trim': !0 }), Prism.hooks.add('before-sanity-check', function (e) { var n = Prism.plugins.NormalizeWhitespace; if (!e.settings || e.settings['whitespace-normalization'] !== !1) { if ((!e.element || !e.element.parentNode) && e.code) return e.code = n.normalize(e.code, e.settings), void 0; var t = e.element.parentNode; var r = /\bno-whitespace-normalization\b/; if (e.code && t && t.nodeName.toLowerCase() === 'pre' && !r.test(t.className) && !r.test(e.element.className)) { for (var i = t.childNodes, o = '', a = '', s = !1, l = 0; l < i.length; ++l) { var c = i[l]; c == e.element ? s = !0 : c.nodeName === '#text' && (s ? a += c.nodeValue : o += c.nodeValue, t.removeChild(c), --l) } if (e.element.children.length && Prism.plugins.KeepMarkup) { var u = o + e.element.innerHTML + a; e.element.innerHTML = n.normalize(u, e.settings), e.code = e.element.textContent } else e.code = o + e.code + a, e.code = n.normalize(e.code, e.settings) } } })) }())
